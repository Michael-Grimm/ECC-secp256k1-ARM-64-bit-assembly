.text

.include "aliases"
.include "commonmacros"

/**
  Macros and functions for parsing Scalar, Point from/into 
  character arrays.
*/

/**
   Helper macros for converting ASCII-Glyphs into integers
   The input must be a valid hex-character array
   To avoid looping through the characters the loops are unrolled.
*/
.macro CONVERT_CHAR_TO_NIBBLE input accumulator shift  
           //Input ascii-character array e.g. "fedcba98" is loaded
           //into 64-bit register in reversed order:  
           //ASCII glyph '8'  '9'  'a'  'b'  'c'  'd'  'e'  'f' 
           //In decimal:  56   57   97   98   99  100  101  102
           //In hex:     0x38 0x39 0x61 0x62 0x63 0x64 0x65 0x66  
           //Register:   0x3839616263646566  ASCII-glyph  "89abcdef"
           //Isolate the right most glyph:                "0000000f"      
           and tmp0, \input, 0xFF    //register:  0x0000000000000066  
                                         
           //Testing for lower/upper case hex-characters and digits
           cmp tmp0, 70 //'F': dec 70, hex 0x46
           bhi is_lower_case\@  // >70 -> 'a','b'... 'f'.
           cmp tmp0, 57 //'9': dec 57, hex 0x39 
           bhi is_upper_case\@ // >57 -> 'A','B' etc.
           //at this point the char represents a digit '0'...'9' 
           sub tmp0, tmp0, 48 //'0': dec 48, hex 0x30               
           b is_converted\@
           is_lower_case\@:
           sub tmp0, tmp0, 87 //'a': dec 97, hex 0x61, minus 10 = 87   
           b is_converted\@
           is_upper_case\@:
           sub tmp0, tmp0, 55  //'A': dec 65, hex 0x41, minus 10 = 55
           is_converted\@:
           //shift value at the right place in the accumulator register
                                    //  glyph:             "f0000000" 
                                    //  register: 0x6600000000000000            
           orr \accumulator, \accumulator, tmp0, lsl \shift 
           lsr \input, \input, 8	//right shift next char in place: "089abcde"
.endm

.macro CONVERT_CHARS_TO_LONG_LONG msi lsi accumulator
           mov \accumulator, xzr
           //16 ascii characters need two 64-bit registers
           //msi: most significant int, lsi: least significant int
           //input "fedcba9876543210" -> msi: 89abcdef lsi: 01234567
           								  //accumulator: 0000000000000000 
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 60 //f000000000000000
           CONVERT_CHAR_TO_NIBBLE \msi \accumulator 56 //fe00000000000000
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 52 //fed0000000000000
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 48 //....
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 44
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 40
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 36
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 32 //fedcba9800000000
		   
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 28 //fedcba9870000000
           CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 24 //....
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 20
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 16
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 12
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator  8
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator  4
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator  0 //fedcba9876543210
.endm

/**
The C compatible function secp256k1_parse_u64
 parses a hex-string (with a fixed length of 16 chars) into an u64 int (unsigned long long int).
 Input:
 io0: Address of a character array with a length of 16 characters: e.g. "fedcba9876543210"
 The chars must be valid hex-characters: '0'...'9','a'...'f' or 'A'...'F'
 Upper and lower casee can be mixed: "fEdcBa9876543210"
 There is no check for invalid chars.
 Output:
 io0 unsigned long long integer // 0xfedcba9876543210
*/
BEGIN_C_FUNCTION secp256k1_parse_u64
           ldp io3, io2, [io0]             
           mov io0, xzr 			              						
           CONVERT_CHARS_TO_LONG_LONG io3 io2 io0
           end_parse:
END_C_FUNCTION secp256k1_parse_u64

// io0 Address of a character-array with a length of 4x16 characters (without \0).
// io1 Address of Scalar.

.macro PARSE_SCALAR arr=io0 scal=io1
           mov tmp4, \scal
           ldp sr1, sr0, [\arr], #16
           ldp sr3, sr2, [\arr], #16
           ldp sr5, sr4, [\arr], #16
           ldp sr7, sr6, [\arr], #16 //increment is necessary, if function is called again
           mov tmp5, \arr
           CONVERT_CHARS_TO_LONG_LONG sr1 sr0 io0
           CONVERT_CHARS_TO_LONG_LONG sr3 sr2 io1
           CONVERT_CHARS_TO_LONG_LONG sr5 sr4 io2
           CONVERT_CHARS_TO_LONG_LONG sr7 sr6 io3
           stp io3, io2, [tmp4], #16
           stp io1, io0, [tmp4], #16 //incrementing in case function is called again
           mov \scal, tmp4 //memory address after this scalar
           mov \arr, tmp5 //actual position in char-array
.endm

/**
The function secp256k1_parse_Scalar
 parses a hex-string into a Scalar.
 Input:
 io0 Address of a character-array with a length of 4x16=64 characters (without \0).
 io1 Resulting Scalar.
*/
BEGIN_C_FUNCTION secp256k1_parse_scalar
			PARSE_SCALAR
END_C_FUNCTION secp256k1_parse_scalar

/*
 The function secp256k1_parse_Point
 parses a String into a Point.
 If a string starts with the two characters '04', it contains both x and y 
 coordinates and has a total length of 66 chars.
 '03' and '02' contain only the x coordinate, with a total length of 34 chars.
 The y coordinate is calculated  from x. 
 '03' signals an odd, '02' an even y coordinate.
 String lengths less than the expected length cause errors or unexpected results.
 Input: 
 io0: Address of char-array. 
 io1: Address of Point
*/
BEGIN_C_FUNCTION secp256k1_parse_point
        INIT_PRIME_P
        mov tmp1, io1 //address of x-coordinate in point into tmp1
		//Load first 2 chars containing "04", "03" or "02"
		ldr  io2, [io0], #2    //contains for example 0x23456789abcdef04
		and  io2, io2, #0xffff //0x0000000000000004 
		mov tmp2, io2
		//tmp2 contains now the ASCII hex values of the leading two chars:
		//'04'= 0x3430 or '03' = 0x3330 or '02' = 0x3230
        PARSE_SCALAR io0 io1   
        //x-coordinate is stored in the point. 
        //io1 points now to y-coordinate in point.
        //Now handle y.
        //the address of y in point is in io1, 
        //the address of x in point is in tmp1
        
        mov tmp3, #0x3430 //'04'
        cmp tmp2, tmp3 //is y present in char array?
        beq y_is_present_in_char_array
        
        PUSH io1 //Save address of y-cordinate in point
        //test_parity
        mov tmp3, #0x3330 //'03'= odd
        cmp tmp2, tmp3 //odd y expected?
        beq odd_expected
        //even
        LOAD_A tmp1
        bl get_even_y_coordinate_from_x_coordinate
        POP io0
        STORE_A io0
        b end_parse_point
        //odd
        odd_expected:
        LOAD_A tmp1
        bl get_odd_y_coordinate_from_x_coordinate
        POP io0
        STORE_A io0
        b end_parse_point
      
        y_is_present_in_char_array:
        PARSE_SCALAR io0 io1 //point.y
        end_parse_point:
END_C_FUNCTION secp256k1_parse_point




.macro INIT_MSKF1
    mov mskf1, 0xf  //000000000000000f
.endm

.macro INIT_MSKF32
	mvn mskf32, xzr, lsr #32 //00000000ffffffff
.endm

.macro CONVERT_NIBBLE_TO_ASCII input accum 
    and tmp2, \input, mskf1    //mskf1 must bi initialized with 0xF
    cmp tmp2, 9
    bhi is_above_9\@
    add tmp2, tmp2, 48 //'0'...'9'
    b is_converted\@
    is_above_9\@: 
    add tmp2, tmp2, 87 //'a'...'f'
    is_converted\@:
    lsl \accum, \accum, #8
    orr \accum, \accum, tmp2
    lsr \input, \input, #4
.endm


.macro CONVERT_U32_TO_ASCII val accum
	CONVERT_NIBBLE_TO_ASCII \val \accum 
	CONVERT_NIBBLE_TO_ASCII \val \accum 
	CONVERT_NIBBLE_TO_ASCII \val \accum 
	CONVERT_NIBBLE_TO_ASCII \val \accum 
	CONVERT_NIBBLE_TO_ASCII \val \accum 
	CONVERT_NIBBLE_TO_ASCII \val \accum 
	CONVERT_NIBBLE_TO_ASCII \val \accum 
	CONVERT_NIBBLE_TO_ASCII \val \accum 
.endm

/**
 * The function secp256k1_u32_to string
 * converts a 32-bit-integer to ascii char array of 8 bytes.
 * Input: 
 * int val in x0
 * Output:
 * String at address in x1
 */
BEGIN_C_FUNCTION secp256k1_u32_to_string
    INIT_MSKF1
    mov x3, xzr
	CONVERT_U32_TO_ASCII x0 x3 
    str x3, [x1]
END_C_FUNCTION secp256k1_u32_to_string


.macro CONVERT_U64_TO_ASCII val lo hi
	CONVERT_U32_TO_ASCII \val \lo 
	CONVERT_U32_TO_ASCII \val \hi   
.endm

/**
 * The function secp256k1_u64_to string
 * converts a 64-bit-integer to ascii char array of 16 bytes.
 * Input: 
 * long long val in io0
 * Output:
 * Address of buffer for the resulting ASCII characters in io1
 */
BEGIN_C_FUNCTION secp256k1_u64_to_string
    INIT_MSKF1
    mov x3, xzr
    mov x4, xzr
	CONVERT_U64_TO_ASCII x0 x3 x4
    stp x4, x3, [x1]  
END_C_FUNCTION secp256k1_u64_to_string

/**
 * The macro CONVERT_SCALAR_TO_ASCII
 * converts a Scalar to an ASCII string with 64 chars.
 * Input:
 * Address of Scalar in io0
 * Output:
 * Address of buffer for the resulting ASCII characters in io1
 */
.macro CONVERT_SCALAR_TO_ASCII
    CLEAR_R
    INIT_MSKF1
    CONVERT_U64_TO_ASCII sa0 sr7 sr6
    CONVERT_U64_TO_ASCII sa1 sr5 sr4
    CONVERT_U64_TO_ASCII sa2 sr3 sr2
    CONVERT_U64_TO_ASCII sa3 sr1 sr0
    
.endm

/**
 * The function secp256k1_scalar_to_string
 * converts a Scalar to a ASCII string with 64 chars.
 * Input:
 * Address of Scalar in io0
 * Output:
 * Address of buffer for the resulting ASCII characters in io1
 */
BEGIN_C_FUNCTION secp256k1_scalar_to_string
	LOAD_A io0
    CONVERT_SCALAR_TO_ASCII
    STORE_R io1  
END_C_FUNCTION secp256k1_scalar_to_string

/**
 * TODO
 * The function secp256k1_scalar_to_der
 * converts a Scalar into a DER encoded string.
 * The function returns the length of the DER string in bytes.
 * The buffer der must have at least 36 bytes.
 * Input:
 * Address of Scalar in io0
 * Output:
 * Address of buffer for the resulting ASCII characters in io1
 */
BEGIN_C_FUNCTION secp256k1_scalar_to_der
	LOAD_A io0
 	mov io0, #68 //The standard length of a Scalar plus 4 bytes for the header
    lsr tmp3, sa3, #63 //if the most significant bit is 1 (a "negative" integer), a "00" must be appended to the header and the size of the integer is 33
    add io0, io0, tmp3      //the result of the function is now 34 or 35
    mov tmp5, #0x3032 //ascii '02'
    mov tmp4, #0x3230 //ascii '20'
    add tmp5, tmp5, tmp3  //now  size is '20' or '21'
    lsl tmp5, tmp5, #16
    orr tmp5, tmp5, tmp4 
    //tmp5 contains the header of the DER encoded string '0220' or '0221'

    cbz tmp3, no00appending
    //is negative, appending '00' is necessary
  //  mov tmp4, #0x3030 //ascii '00'
    //strh tmph4, [io1], #2
    no00appending:
   strh tmph5, [io1], #2
    lsr tmp5, tmp5, #16
    strh tmph5, [io1], #2
 
    CONVERT_SCALAR_TO_ASCII
    STORE_R io1 
END_C_FUNCTION secp256k1_scalar_to_der










