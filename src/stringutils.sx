.text

.include "aliases"
.include "commonmacros"

/**
  Macros and functions for parsing Scalar, Point from/into 
  character arrays.
*/

/**
   Helper macros for converting ASCII-Glyphs into integers
   The input must be a valid hex-character array
   To avoid looping through the characters the loops are unrolled.
*/
.macro CONVERT_CHAR_TO_NIBBLE input accumulator shift  
           //Input ascii-character array e.g. "fedcba98" is loaded
           //into 64-bit register in reversed order:  
           //ASCII glyph '8'  '9'  'a'  'b'  'c'  'd'  'e'  'f' 
           //In decimal:  56   57   97   98   99  100  101  102
           //In hex:     0x38 0x39 0x61 0x62 0x63 0x64 0x65 0x66  
           //Register:   0x3839616263646566  ASCII-glyph  "89abcdef"
           //Isolate the right most glyph:                "0000000f"      
           and tmp0, \input, 0xFF    //register:  0x0000000000000066  
                                         
           //Testing for lower/upper case hex-characters and digits
           cmp tmp0, 70 //'F': dec 70, hex 0x46
           bhi is_lower_case\@  // >70 -> 'a','b'... 'f'.
           cmp tmp0, 57 //'9': dec 57, hex 0x39 
           bhi is_upper_case\@ // >57 -> 'A','B' etc.
           //at this point the char represents a digit '0'...'9' 
           sub tmp0, tmp0, 48 //'0': dec 48, hex 0x30               
           b is_converted\@
           is_lower_case\@:
           sub tmp0, tmp0, 87 //'a': dec 97, hex 0x61, minus 10 = 87   
           b is_converted\@
           is_upper_case\@:
           sub tmp0, tmp0, 55  //'A': dec 65, hex 0x41, minus 10 = 55
           is_converted\@:
           //shift value at the right place in the accumulator register
                                    //  glyph:             "f0000000" 
                                    //  register: 0x6600000000000000            
           orr \accumulator, \accumulator, tmp0, lsl \shift 
           lsr \input, \input, 8	//right shift next char in place: "089abcde"
.endm

.macro CONVERT_CHARS_TO_LONG_LONG msi lsi accumulator
           mov \accumulator, xzr
           //16 ascii characters need two 64-bit registers
           //msi: most significant int, lsi: least significant int
           //input "fedcba9876543210" -> msi: 89abcdef lsi: 01234567
           								  //accumulator: 0000000000000000 
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 60 //f000000000000000
           CONVERT_CHAR_TO_NIBBLE \msi \accumulator 56 //fe00000000000000
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 52 //fed0000000000000
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 48 //....
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 44
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 40
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 36
		   CONVERT_CHAR_TO_NIBBLE \msi \accumulator 32 //fedcba9800000000
		   
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 28 //fedcba9870000000
           CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 24 //....
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 20
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 16
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator 12
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator  8
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator  4
		   CONVERT_CHAR_TO_NIBBLE \lsi \accumulator  0 //fedcba9876543210
.endm

/**
The C compatible function secp256k1_parse_u64
 parses a hex-string (with a fixed length of 16 chars) into an u64 int (unsigned long long int).
 Input:
 io0: Address of a character array with a length of 16 characters: e.g. "fedcba9876543210"
 The chars must be valid hex-characters: '0'...'9','a'...'f' or 'A'...'F'
 Upper and lower casee can be mixed: "fEdcBa9876543210"
 There is no check for invalid chars.
 Output:
 io0 unsigned long long integer // 0xfedcba9876543210
*/
BEGIN_C_FUNCTION secp256k1_parse_u64
           ldp io3, io2, [io0]             
           mov io0, xzr 			              						
           CONVERT_CHARS_TO_LONG_LONG io3 io2 io0
           end_parse:
END_C_FUNCTION secp256k1_parse_u64

// io0 Address of a character-array with a length of 4x16 characters (without \0).
// io1 Address of Scalar.

.macro PARSE_SCALAR arr=io0 scal=io1
           mov tmp4, \scal
           ldp sr1, sr0, [\arr], #16
           ldp sr3, sr2, [\arr], #16
           ldp sr5, sr4, [\arr], #16
           ldp sr7, sr6, [\arr], #16 //increment is useful, if function is called again
           mov tmp5, \arr
           CONVERT_CHARS_TO_LONG_LONG sr1 sr0 io0
           CONVERT_CHARS_TO_LONG_LONG sr3 sr2 io1
           CONVERT_CHARS_TO_LONG_LONG sr5 sr4 io2
           CONVERT_CHARS_TO_LONG_LONG sr7 sr6 io3
           stp io3, io2, [tmp4], #16
           stp io1, io0, [tmp4], #16 //incrementing in case function is called again
           mov \scal, tmp4 //memory address after this scalar
           mov \arr, tmp5 //actual position in char-array
.endm

/**
The function secp256k1_parse_Scalar
 parses a hex-string into a Scalar.
 Input:
 io0 Address of a character-array with a length of 4x16=64 characters (without \0).
 io1 Resulting Scalar.
*/
BEGIN_C_FUNCTION secp256k1_parse_scalar
			PARSE_SCALAR
END_C_FUNCTION secp256k1_parse_scalar

/*
 The function secp256k1_parse_Point
 parses a String into a Point.
 If a string starts with the two characters '04', it contains both x and y 
 coordinates and has a total length of 66 chars.
 '03' and '02' contain only the x coordinate, with a total length of 34 chars.
 The y coordinate is calculated  from x. 
 '03' signals an odd, '02' an even y coordinate.
 String lengths less than the expected length cause errors or unexpected results.
 Input: 
 io0: Address of char-array. 
 io1: Address of Point
*/
BEGIN_C_FUNCTION secp256k1_parse_point
        INIT_PRIME_P
        mov tmp1, io1 //address of x-coordinate in point into tmp1
		//Load first 2 chars containing "04", "03" or "02"
		ldr  io2, [io0], #2    //contains for example 0x23456789abcdef04
		and  io2, io2, #0xffff //0x0000000000000004 
		mov tmp2, io2
		//tmp2 contains now the ASCII hex values of the leading two chars:
		//'04'= 0x3430 or '03' = 0x3330 or '02' = 0x3230
        PARSE_SCALAR io0 io1   
        //x-coordinate is stored in the point. 
        //io1 points now to y-coordinate in point.
        //Now handle y.
        //the address of y in point is in io1, 
        //the address of x in point is in tmp1
        
        mov tmp3, #0x3430 //'04'
        cmp tmp2, tmp3 //is y present in char array?
        beq y_is_present_in_char_array
        
        PUSH io1 //Save address of y-cordinate in point
        //test_parity
        mov tmp3, #0x3330 //'03'= odd
        cmp tmp2, tmp3 //odd y expected?
        beq odd_expected
        //even
        LOAD_A tmp1
        bl get_even_y_coordinate_from_x_coordinate
        POP io0
        STORE_A io0
        b end_parse_point
        //odd
        odd_expected:
        LOAD_A tmp1
        bl get_odd_y_coordinate_from_x_coordinate
        POP io0
        STORE_A io0
        b end_parse_point
      
        y_is_present_in_char_array:
        PARSE_SCALAR io0 io1 //point.y
        end_parse_point:
END_C_FUNCTION secp256k1_parse_point

