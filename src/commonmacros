

/**
Macro INIT_PRIME_P
initializes the regs for prime p
*/
.macro INIT_PRIME_P
           //load c of prime into ppc, load the least significant u64 of p, into pp0
           adr pp1, prime_p_and_c
           ldp pp0, ppc, [pp1] 
           mvn pp1, xzr //0xffffffffffffffff is now in pp1
.endm

/**
Macro INIT_ORDER_N
initializes the regs for prime n 
*/
.macro INIT_ORDER_N
           //load prime n into regs on0 - on3 
           adr on3, secp256k1_n
           ldp on0, on1, [on3], #16
           ldp on2, on3, [on3]    
           //load d of prime into ond1 and ond0
           adr ond0, secp256k1_d
           ldp ond1, ond0, [ond0]
.endm
 
 
/**
Macro LOAD_B_WITH_HALF_N
initializes the regs sb0...sb3 with the half of order n
*/
.macro LOAD_B_WITH_HALF_N
           adr sb3, secp256k1_n_half
           ldp sb0, sb1, [sb3], #16
           ldp sb2, sb3, [sb3]    
.endm 
 


/**
 Tests if Scalar A has zero values in all registers
 Returns 0 in io0 if scalar is zero otherwise 1
*/
.macro IS_A_ZERO
      mov io0, #1
      cbnz sa0, end_test\@
      cbnz sa1, end_test\@
      cbnz sa2, end_test\@
	  cbnz sa3, end_test\@
      mov io0, xzr
      end_test\@:
.endm

/**
 Tests if Scalar R (lo) has zero values in all registers (sr0...sr3)
 Returns 0 in io0 R (lo) is zero otherwise 1
*/
.macro IS_R_LO_ZERO
      mov io0, #1
      cbnz sr0, end_test\@
      cbnz sr1, end_test\@
      cbnz sr2, end_test\@
	  cbnz sr3, end_test\@
      mov io0, xzr
      end_test\@:
.endm

.macro COPY_B_TO_A
		mov sa0, sb0
		mov sa1, sb1
		mov sa2, sb2
		mov sa3, sb3
.endm

.macro COPY_A_TO_R_LO
		mov sr0, sa0
		mov sr1, sa1
		mov sr2, sa2
		mov sr3, sa3
.endm

.macro COPY_B_TO_R_LO
		mov sr0, sb0
		mov sr1, sb1
		mov sr2, sb2
		mov sr3, sb3
.endm

.macro COPY_R_LO_TO_A
		mov sa0, sr0
		mov sa1, sr1
		mov sa2, sr2
		mov sa3, sr3
.endm


.macro COPY_R_LO_TO_B
		mov sb0, sr0
		mov sb1, sr1
		mov sb2, sr2
		mov sb3, sr3
.endm



/**
Macro LOAD_A_B
Loads scalar a from address in reg0 into regs sa0...sa3,
scalar b from address into sb0...sb3
*/
.macro LOAD_A_B reg0=io0 reg1=io1
        //load scalar a 
        mov sa3, \reg0
        ldp sa0, sa1, [sa3], #16
        ldp sa2, sa3, [sa3]
        //load scalar b 
        mov sb3, \reg1
        ldp sb0, sb1, [sb3], #16
        ldp sb2, sb3, [sb3]
.endm

.macro LOAD_A reg0=io0
        mov sa3, \reg0
        ldp sa0, sa1, [sa3], #16
        ldp sa2, sa3, [sa3]
.endm

.macro LOAD_B reg0=io1
        mov sb3, \reg0
        ldp sb0, sb1, [sb3], #16
        ldp sb2, sb3, [sb3]
.endm


.macro SET_A_TO_1
        mov sa0, #1
        mov sa1, xzr
        mov sa2, xzr
        mov sa3, xzr
.endm

.macro SET_A_TO_7
        mov sa0, #7
        mov sa1, xzr
        mov sa2, xzr
        mov sa3, xzr
.endm

.macro SET_B_TO_1
        mov sb0, #1
        mov sb1, xzr
        mov sb2, xzr
        mov sb3, xzr
.endm

.macro LOAD_K reg=io1
        mov sk3, \reg
        ldp sk0, sk1, [sk3], #16
        ldp sk2, sk3, [sk3]
.endm



/**
Macro STORE_R_LO
Stores sr0...sr3 in memory at address in the given reg
*/
.macro STORE_R_LO reg  
        stp sr0, sr1, [\reg], #16
        stp sr2, sr3, [\reg]
.endm
/**
Macro STORE_R_HI
Stores sr4...sr7 in memory at address in the given reg
*/
.macro STORE_R_HI reg  
        stp sr4, sr5, [\reg], #16
        stp sr6, sr7, [\reg]
.endm

/**
Macro STORE_A
Stores a (regs sa0...sa3) in memory at address in the given reg
*/
.macro STORE_A reg
        stp sa0, sa1, [\reg], #16
        stp sa2, sa3, [\reg]
.endm

/**
Macro STORE_B
Stores b (regs sb0...sb3) in memory at address in the given reg
*/
.macro STORE_B reg
        stp sb0, sb1, [\reg], #16
        stp sb2, sb3, [\reg]
.endm

/**
Macro STORE_K
Stores k (regs sk0...sk3) in memory at address in the given reg
*/
.macro STORE_K reg
        stp sk0, sk1, [\reg], #16
        stp sk2, sk3, [\reg]
.endm

.macro COPY_INTO_K_FROM reg1 reg2 reg3 reg4
           mov sk0, \reg1
           mov sk1, \reg2
           mov sk2, \reg3
           mov sk3, \reg4
.endm


.macro COPY_K_INTO reg1 reg2 reg3 reg4
           mov \reg1, sk0
           mov \reg2, sk1
           mov \reg3, sk2
           mov \reg4, sk3
.endm

.macro COPY_P_INTO reg1 reg2 reg3 reg4
           mov \reg1, pp0
           mov \reg2, pp1
           mov \reg3, pp1
           mov \reg4, pp1
.endm




/*
Macros for the boilerplate of function declaration,
and saveing/restoring regs on the stack
*/

.macro PUSH reg1 reg2=xzr
        stp \reg1, \reg2, [sp, #-16]!
.endm

.macro POP reg1 reg2=xzr
        ldp \reg1, \reg2, [sp], #16
.endm


//A global C-compatible function that preserves the callee saved regs
.macro BEGIN_C_FUNCTION function_name
 	.type \function_name, %function
    .global \function_name
	\function_name:
	    stp csr0, csr1, [sp, #-16]!
        stp csr2, csr3, [sp, #-16]!
        stp csr4, csr5, [sp, #-16]!
        stp csr6, csr7, [sp, #-16]!
        stp csr8, csr9, [sp, #-16]!    
        stp frmptr, prclrg, [sp, #-16]!
.endm

.macro END_C_FUNCTION function_name
        ldp frmptr, prclrg, [sp], #16 
        ldp csr8, csr9, [sp], #16
        ldp csr6, csr7, [sp], #16
        ldp csr4, csr5, [sp], #16
        ldp csr2, csr3, [sp], #16
        ldp csr0, csr1, [sp], #16  
        ret
        .size \function_name, (. - \function_name) 
.endm

//A global function that does not preserve the callee saved regs
.macro BEGIN_GLOBAL_FUNCTION function_name
 	.type \function_name, %function
    .global \function_name
	\function_name:
		stp frmptr, prclrg, [sp, #-16]!
.endm

.macro END_GLOBAL_FUNCTION function_name
		ldp frmptr, prclrg, [sp], #16
        ret
        .size \function_name, (. - \function_name) 
.endm










